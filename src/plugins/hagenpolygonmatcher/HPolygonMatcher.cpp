#include <qmath.h>

#include "HPolygonMatcher.h"

#include "qgsmaplayer.h"
#include "qgsvectorlayer.h"
#include "qgsapplication.h"
#include "qgisinterface.h"
#include "qgsguiutils.h"
#include "qgslayertreeview.h"
#include "qgsgeometry.h"

#include <QMenu>
#include <QAction>

static QString sName=QObject::tr("Polygon Matcher");
static QString sDescr= QObject::tr("Flexible polygon matching for applications like symmetry detection");
static QString sCat= QObject::tr("Vector");
static QString sVer= QObject::tr("Version 0.1");

HPolygonMatcher::HPolygonMatcher(QgisInterface *interface) :
	QgisPlugin(
		sName, 
		sDescr, 
		sCat, 
		sVer, 
		QgisPlugin::UI),
	interface(interface),
	mScanaction(nullptr),
	intermediate(nullptr)
{
}


HPolygonMatcher::~HPolygonMatcher()
{
	if (intermediate != nullptr)
	{
		delete intermediate;
	}
}

void HPolygonMatcher::initGui()
{
	intermediate = new Intermediate();

	mSep=interface->layerMenu()->addSeparator();
	mScanaction = interface->layerMenu()->addAction("Scan for symmetry");
	mScanaction->setEnabled(false);
	connect(mScanaction, SIGNAL(triggered()), this, SLOT(scan()));

	QgsLayerTreeView *layerv = interface->layerTreeView();
	connect(layerv, SIGNAL(currentLayerChanged(QgsMapLayer *)), this, SLOT(currentLayerChanged(QgsMapLayer *)));
}

void HPolygonMatcher::unload()
{
	if (intermediate != nullptr)
	{
		delete intermediate;
		intermediate = nullptr;
	}

	disconnect(mScanaction, SIGNAL(triggered()), this, SLOT(scan()));
	interface->layerMenu()->removeAction(mSep);
	interface->layerMenu()->removeAction(mScanaction);

	QgsLayerTreeView *layerv = interface->layerTreeView();
	disconnect(layerv, SIGNAL(currentLayerChanged(QgsMapLayer *)), this, SLOT(currentLayerChanged(QgsMapLayer *)));
}

void HPolygonMatcher::currentLayerChanged(QgsMapLayer *layer)
{
	if (layer)
	{
		if (layer->type() == QgsMapLayerType::VectorLayer)
		{
			mLayer = dynamic_cast<QgsVectorLayer*>(layer);
			if (mLayer->geometryType() == QgsWkbTypes::GeometryType::PolygonGeometry)
			{
				mScanaction->setEnabled(true);
			}
			else
			{
				mScanaction->setEnabled(false);
				mLayer = nullptr;
			}
		}
		else
		{
			mScanaction->setEnabled(false);
			mLayer = nullptr;
		}
	}
	else
	{
		mScanaction->setEnabled(false);
		mLayer = nullptr;
	}
}

void HPolygonMatcher::scan()
{
	QgsFeatureIterator it = mLayer->getFeatures();
	QVector<QgsPolygonXY> *polygons = new QVector<QgsPolygonXY>();
	if (it.isValid())
	{
		for (QgsFeature feature; it.nextFeature(feature);)
		{
			if (feature.isValid() && feature.hasGeometry())
			{
				polygons->push_back(feature.geometry().asPolygon());
			}
		}
	}
	intermediate->abort();
	intermediate->scan(polygons);
}

//////////////////////////////////////////////////////////////////////////
//
//
//  THE FOLLOWING CODE IS AUTOGENERATED BY THE PLUGIN BUILDER SCRIPT
//    YOU WOULD NORMALLY NOT NEED TO MODIFY THIS, AND YOUR PLUGIN
//      MAY NOT WORK PROPERLY IF YOU MODIFY THIS INCORRECTLY
//
//
//////////////////////////////////////////////////////////////////////////


/**
* Required extern functions needed  for every plugin
* These functions can be called prior to creating an instance
* of the plugin class
*/
// Class factory to return a new instance of the plugin class
QGISEXTERN QgisPlugin *classFactory(QgisInterface *qgisInterfacePointer)
{
	return new HPolygonMatcher(qgisInterfacePointer);
}
// Return the name of the plugin - note that we do not user class members as
// the class may not yet be insantiated when this method is called.
QGISEXTERN QString name()
{
	return sName;
}

// Return the description
QGISEXTERN QString description()
{
	return sDescr;
}

// Return the type (either UI or MapLayer plugin)
QGISEXTERN int type()
{
	return QgisPlugin::UI;
}

// Return the category
QGISEXTERN QString category()
{
	return sCat;
}

// Return the version number for the plugin
QGISEXTERN QString version()
{
	return sVer;
}

QGISEXTERN QString icon()
{
	return QStringLiteral(":/hagenpolygonmatcher/icon.svg");
}

// Delete ourself
QGISEXTERN void unload(QgisPlugin *pluginPointer)
{
	delete pluginPointer;
}
